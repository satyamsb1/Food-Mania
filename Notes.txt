#Day-2 Igniting out app 
	- Things that work behind the scene and we dont know what happens
	- Things tha happen when we use create react app.
	- React cannot on individual level make our application fast; we need many packages to achive
	that speed.

	- Intro to npm;
		- packages and dependencies are same.
	- Bundler:-
		- Minification, Dependency Management, Optimization etc;
		- We are going to use parcel
		- We make production ready app using bundler. 
		- npm i -D parcel this is known as dev dependencies and used for development purposes.
		- npm i parcel these are used in production also.
			#Parcel (https://parceljs.org/)
				- Dev Build
				- Local Server
				- HMR = Hot module Replacement
				- File Watching Algorith which is written in C++
				- Caching - For faster Builds
				- Image Optimization
				- Minification
				- Bundling
				- Compress
				- Consistent Hashing
				- Code splitting
				- Differential Bundling -  for older versions of browsers
				- Diagnostics
				- Error Handling
				- Tree shaking (Remove unused code)
				- Different dev and prod bundles
		- BrowsersList - Used to tell browsers which verisions app will run on 
			- Offical Website (https://browserslist.dev/?q=bGFzdCAyIHZlcnNpb25z)
	
#Day3 - Laying the foundation
	- JSX
		- JSX is not html in js JSX is diffrent from the html.
		- You can call it has html-like or xml-like syntax
		- const jsxHeading = <h1 id="heading">This is the jsx heading</h1> this is an react element this also forms a 
		javascript object;
		- JSX makes easy to create and read the code
		- JS engine only understands the ecma(es6) script, Engine wont be able to read jsx (This is not valid pure js)
		- Here, parcel helps us again. The code is first transpiled(converted to the code browsers can understand) before it goes to the js engine.
		- Parcel dont do this transpilation process on its own it takes help from "BABEL".
		- Babel is a package it is bought into the project when we install parcel;
		- JSX --> React code is done by babel.
		- First the JSX is converted to the React.createElement, then this element is converted to the JS object and then rendered on to the browser as html element.
		- Babel also transpiles the new code to the older versions of the code so the browsers who support older versions of JS can understand.
		- In jsx to give a class then we have to use className="XYZ" not class="XYZ".
		- Names of Attibutes in jsx must be camel-cased.
		- If we have to write jsx in multipl lines we have to wrap the code in paranthesis, Altought it is not necessary 
		to use brackets if the code is written in single line.
	
	- React Component
		- Everything in react is Component.
		- Two types of components
			1. Class based components (old way) uses JS classes
			2. Functional components (new way) Uses JS functions
		-*- Functional components
			- Functional compoenent is nothing but a javascript function.
			- Name should start from a capital letter. 
			- Functional component is nothing but a js function which returns a jsx element i.e. an react element.
			- Multiple ways to write a functional compoenent 
				1. const HeadingComponent = () =>{
					return <h1>This is a react functional Component</h1>;
				};
				2. const HeadingComponent = () => <h1>This is a react functional Component</h1>;  
				3. const HeadingComponent = () => (
					<h1>This is a react functional Component</h1>;  
				);
			- Component compostion is the process of using a component inside another component.
			- In jsx if we use {We can code any javascript inside} angular brackets.
			
#Day4 - Talk is cheap, show me the code
	- Building a food delivery app using react
	- Component our app will have
		- Header
			- logo
			- Nav-items
		- Body
		  	- Search
			- Restaurant container
				- RestaurantCard
		Footer
			- Copyright
			- Links
			- Address
			- Contact 
	- Props
		- Props are just normal arguments for the component/function.
	- Config Driven UI 
		-  When you build real a world application so you want should your website work in many country or many place we control our fontend it is known as using Config-Driven UI
	- Conclusion
		build the reusable restaurantcard component
		Intro to Swiggy API

#Day5 - Lets get hooked
	-Export and imports
		- Default export
			export default component
			import Component from "path";
		- Named export/imports
			export const component;
			import {Component} from "path";
	
	- React Hooks
		- Normal JS function, These functions have diff superpowers.
		- Two most used Hooks	
			- useState(); Superpowerful state variables in react
			- useEffect(); 
		- Whenever the state variable updates, react rerenders that particular component;
		- this is performed with the help of DOM manipulation which is one of the core feature of react

		- Reconciliation Algorithm (React Fiber)
			- Virtual DOM is a representation of actual DOM. i.e. React elements
		- Diff Algorithm 
			- Finds out difference between two virtual dom i.e. Old one and the new one.
			- And then those UI changes are updated
			- react has virtual DOM and Does efficient DOM manipulation. Thats why React is fast. 

#Day6 - Exploring the world.
	- Monolithic architecture
		- A monolithic architecture refers to a software application design where all the components and features of the application are tightly integrated and deployed as a single, indivisible unit.
	- Microservices architecture
		- Microservices architecture is an architectural style that structures an application as a collection of small, loosely coupled, and independently deployable services.
		- These Microservices can used diff tech stack for diff types of services.
		- Services are independent of each other but are loosely coupled.
	
	- API Calling
		- Loading the page -> Rendering the page -> Making API call -> Again Rendering.
	
	- useEffect() hook 
		- 2 arguments	
			- Arrow function which is call back function.
			- Dependency Array.
		- First react will render the compoenent and then it will call the callback function from the useEffect hook.
		- Thats why we fetch Our data inside useEffect hook.

	- Conditional rendering
		- Rendering of the page on the basis of a condition is known as conditional rendering.

	- If a useState() hook is a constant variable how does it get updated?
		- const [btnName, setBtnName] = useState("Login");
		when we use setBtnName the component is re rendered and this time the btnName is a new variable with the updated value, Thats why although the useState() hook is a constant variable the value can be changed.

	- Search Function
		- Create a new local state variable first and then bind it to the input-box.
		- As soon as the input changes we'll have to update the state variable.
		- We will use onchange handler
			onChange((e)=>{
				setSearchText(e.target.value);
			})
		- With every charachter we type in the input the compoenent is re-rendered. As the state variable is updated with every input we type.
		i.e react triggers a Reconciliation cycle per every input.

		- We use multiple state variables to keep the data as when we filter out the searched data and search again we search within previously filtered data to avoid this we keep filtering from the original state variable which is not yet filtered.



		- it is important to know why things dont work in certain way to understand how they work.